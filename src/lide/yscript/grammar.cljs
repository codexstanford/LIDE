(ns lide.yscript.grammar)

(def bnf
  "code = block { block }
block = context | defaults | example | fact-declaration | (* include | *) order | rule | verbs
text = #'\"[^\"]\"'
descriptor = #'.*'
context = 'CONTEXT' context
defaults = 'DEFAULT' generic-type 'STYLE' text
fact-declaration = [ 'GOAL' ] fact-type descriptor [ 'FROM' context ] [ 'PROVIDES' ] { attachment | explanation | info | prompt | range | translation } [ statements ]
fact-type = [qualifier] [type 'FACT' | 'FACT']
qualifier = 'SYSTEM' | 'UNREPORTED' | 'UNNAMED' | 'INFORMAL' | 'GENDER-NEUTRAL'
attachment = 'ATTACH' ['DISPLAYED'] [qualifier] 'REPORT'|'DOCUMENT'|'TEMPLATE' descriptor ['AS' descriptor]
explanation = 'EXPLAIN' [ 'UNKNOWN' | descriptor ] 'AS' text
info = 'INFO' text
prompt = 'PROMPT' text
range = 'RANGE' arith-expr [ 'TO' arith-expr ]
translation = 'TRANSLATE' [ 'RANGE' | 'UNKNOWN' | descriptor ] 'AS' text
fact-type = generic-type | named-subject
generic-type = 'BOOLEAN'|'DATE'|'GENDER'|'INTEGER'|'MONEY'|'NUMBER'|'STRING'
named-subject = 'PERSON' | 'THING' | 'PERSON-THING'
verbs = 'VERB' | 'VERBS' descriptor
(* include = 'INCLUDE' file-name *)
example = example-header example-body
example-header = ['GOAL'] 'EXAMPLE' ['RULE'] [descriptor] 'PROVIDES'
example-body = 'IF' bool-expr 'THEN' assignment
order = 'ORDER' descriptor { 'THEN' descriptor }
rule = rule-header statements
rule-header = ['GOAL'] rule-type ['RULE'] [descriptor] 'PROVIDES'
rule-type = 'BACKWARD'|'DAEMON'|'DOCUMENT'|'FORWARD'|'PROCEDURE'|'RULE'
statements = statement { statement }
statement = assignment|call|case|determine|exit|forget|if|(* include| *)repeat|say|while|write|'BEGIN' statements 'END'
assignment = [ 'ASSERT' ] descriptor { 'AND' descriptor } | descriptor 'IS'|'ONLY' 'IF' expression
call = 'CALL' | 'SUBRULE' | 'NEXT' ['GOAL'] descriptor [ 'FROM' descriptor ]
case = 'CASE' descriptor { 'WHEN' descriptor [ 'THEN' ] statement }
determine = 'DETERMINE' descriptor
exit = 'EXIT' ['SESSION']
forget = 'FORGET' 'ALL' | descriptor
if = 'IF' expression 'THEN' statement [ 'ELSE' statement ]
say = 'SAY' text
repeat = 'REPEAT' statements 'UNTIL' expression
write = ['NUMBERED'] ['LEVEL' natural-number] 'PARAGRAPH'|'LINE'|'TEXT' text
natural-number = digit { digit }
digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
while = 'WHILE' expression 'DO' statement
expression = bool-expr { 'OR'|'OR/WITH' bool-expr }
bool-expr = and-or-expr { 'AND'|'AND/WITH' and-or-expr }
and-or-expr = rel-expr { 'AND/OR'|'AND/OR/WITH' rel-expr }
rel-expr = arith-expr { ['IS'] rel-op ['THAN'|'TO'] arith-expr }
arith-expr = term { 'PLUS'|'MINUS' } term
term = factor { 'TIMES'|'DIVIDED' ['BY'] } factor
factor = {pre-unary-op} descriptor [post-unary-op]
rel-op = 'LESS'|'GREATER'|'LESSEQUAL'|'GREATEREQUAL'|'EQUAL'|'EQUALS'|'NOT' 'EQUAL'|'NOT' 'EQUALS'
pre-unary-op = 'NOT'|'MINUS'|'PLUS'|'DAY'|'MONTH'|'YEAR'|'HOUR'|'MINUTE'|'SECOND'|'UNKNOWN'
post-unary-op = 'DAY'|'WEEK'|'MONTH'|'YEAR'|'DAYS'|'WEEKS'|'MONTHS'|'YEARS'|'HOURS'|'MINUTES'|'SECONDS'")
